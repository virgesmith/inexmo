import importlib
import inspect
import os
import sys
from collections import defaultdict
from dataclasses import dataclass, field
from functools import cache, wraps
from hashlib import sha256
from pathlib import Path
from typing import Any, Callable, Self

import numpy as np
from pybind11.setup_helpers import Pybind11Extension, build_ext
from setuptools import setup

from inexmo import __version__ as version
from inexmo.errors import CompilationError
from inexmo.utils import get_function_scope, translate_function_signature


@dataclass(frozen=True)
class FunctionSpec:
    name: str
    body: str
    scope: tuple[str, ...]

    def qualified_cpp_name(self) -> str:
        if self.scope:
            return f"_{'_'.join(self.scope)}_{self.name}"
        return f"_{self.name}"


@dataclass
class ModuleSpec:
    """
    Dataclass for accumulating functions to be built within a module
    """

    functions: set[FunctionSpec] = field(default_factory=set[FunctionSpec])
    headers: set[str] = field(default_factory=set[str])
    define_macros: set[str] = field(default_factory=set[str])
    extra_compile_args: set[str] = field(default_factory=set[str])
    extra_link_args: set[str] = field(default_factory=set[str])

    def add_function(
        self,
        function: FunctionSpec,
        *,
        headers: set[str] | None = None,
        define_macros: set[str] | None = None,
        extra_compile_args: set[str] | None = None,
        extra_link_args: set[str] | None = None,
    ) -> Self:
        self.functions.add(function)
        self.headers |= headers or set()
        self.define_macros = define_macros or set()
        self.extra_compile_args |= extra_compile_args or set()
        self.extra_link_args |= extra_link_args or set()
        return self

    def make_source(self, module_name: str) -> tuple[str, str]:
        headers = "\n".join(f"#include {h}" for h in self.headers)

        function_defs = "\n".join(
            _function_template.format(function_name=f.qualified_cpp_name(), function_body=f.body)
            for f in self.functions
        )
        # create the code without the hash
        code = _module_template.format(
            version=version,
            extra_headers=headers,
            define_macros=" ".join(self.define_macros),
            extra_compile_args=" ".join(self.extra_compile_args),
            extra_link_args=" ".join(self.extra_link_args),
            module_name=module_name,
            function_definitions=function_defs,
        )
        # return code and hash
        return code, sha256(code.encode()).hexdigest()


_module_registry: dict[str, ModuleSpec] = defaultdict(ModuleSpec)

_module_template = """
// generated by inexmo {version}
// defines: {define_macros}
// extra cxxflags: {extra_compile_args}
// extra ldflags: {extra_link_args}

{extra_headers}
#include <pybind11/pybind11.h>

namespace py = pybind11;

PYBIND11_MODULE({module_name}, m) {{
  m.doc() = "{module_name} module generated by inexmo {version}";
  m.attr("__checksum__") = "__HASH__";
  {function_definitions}
}}
"""

_function_template = """
  m.def("{function_name}", {function_body});

"""

# TODO make this configurable?
module_root_dir = Path("./ext")
# ensure the module directory is available to Python
sys.path.append(str(module_root_dir))


def _parse_macros(macro_list: set[str]) -> dict[str, str | None]:
    """Map ["DEF1", "DEF2=3"] to {"DEF1": None, "DEF2": "3"}"""
    return {kv[0]: kv[1] if len(kv) == 2 else None for d in macro_list for kv in [d.split("=", 1)]}


def _build_module_impl(
    module_name: str,
    module_spec: ModuleSpec,
) -> None:
    ext_name = module_name

    module_dir = module_root_dir / ext_name
    module_dir.mkdir(exist_ok=True, parents=True)

    code, hashval = module_spec.make_source(module_name)

    # if a built module already exists, and matches the hash of the source code, just use it
    try:
        module = importlib.import_module(f"{ext_name}.{module_name}")
        if module.__checksum__ == hashval:
            return
    except ImportError:
        pass

    # save the code with the hash embedded
    with open(module_dir / "module.cpp", "w") as fd:
        fd.write(code.replace("__HASH__", str(hashval)))

    ext_modules = [
        Pybind11Extension(
            ext_name,
            ["module.cpp"],
            define_macros=list(_parse_macros(module_spec.define_macros).items()),
            extra_compile_args=list(module_spec.extra_compile_args),
            extra_link_args=list(module_spec.extra_link_args),
            include_dirs=[np.get_include()],
            cxx_std=20,
        )
    ]

    cwd = Path.cwd()
    try:
        os.chdir(module_dir)
        setup(
            name=ext_name,
            ext_modules=ext_modules,
            script_args=["build_ext", "--inplace"],
            cmdclass={"build_ext": build_ext},
        )
    except SystemExit as e:
        raise CompilationError(str(e) + ". See logs for more info") from e
    finally:
        os.chdir(cwd)


@cache
def _build_module(module_name: str) -> object:
    _build_module_impl(module_name, _module_registry[module_name])
    return importlib.import_module(f"{module_name}.{module_name}")


@cache
def _get_function(module_name: str, function_name: str) -> Any:
    module = _build_module(module_name)
    return getattr(module, function_name)


def compile(
    *,
    vectorise: bool = False,
    define_macros: list[str] | None = None,
    extra_headers: list[str] | None = None,
    extra_compile_args: list[str] | None = None,
    extra_link_args: list[str] | None = None,
) -> Callable[..., Callable[..., Any]]:
    """
    Decorator factory for compiling C/C++ function implementations into extension modules.

    Parameters:
        vectorise (bool, optional): If True, vectorizes the compiled function for array operations.
        extra_headers (list[str], optional): Additional header files to include during compilation.
        extra_compile_args (list[str], optional): Extra arguments to pass to the compiler.
        extra_link_args (list[str], optional): Extra arguments to pass to the linker.

    Returns:
        Callable[..., Callable[..., Any]]: A function that when called, will return the compiled function.
    """

    def register_function(func: Callable[..., Any]) -> Callable[..., Any]:
        """This registers the function, actual compilation is deferred"""
        scope = get_function_scope(func)

        sig, headers = translate_function_signature(func)
        module_name = f"{Path(inspect.getfile(func)).stem}_ext"  # noqa: F821
        function_body = sig + " {" + (func.__doc__ or "") + "}"

        if vectorise:
            function_body = f"py::vectorize({function_body})"
            headers.add("<pybind11/numpy.h>")

        function_spec = FunctionSpec(name=func.__name__, body=function_body, scope=scope)

        _module_registry[module_name].add_function(
            function_spec,
            headers=headers | set(extra_headers or []),
            define_macros=set(define_macros or []),
            extra_compile_args=set(extra_compile_args or []),
            extra_link_args=set(extra_link_args or []),
        )

        @wraps(func)
        def call_function(*args: Any, **kwargs: Any) -> Any:
            """Compilation is deferred until here (and cached)"""
            return _get_function(module_name, function_spec.qualified_cpp_name())(*args, **kwargs)

        return call_function

    return register_function
