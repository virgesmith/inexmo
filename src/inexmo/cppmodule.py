from dataclasses import dataclass, field
from hashlib import sha256
from typing import Self

from itrx import Itr

from inexmo import __version__ as version
from inexmo.utils import _deduplicate, group_headers

_module_template = """
// generated by inexmo {version}
// cxx_std: {cxx_std}
// defines: {define_macros}
// extra include paths: {extra_include_paths}
// extra cxxflags: {extra_compile_args}
// extra ldflags: {extra_link_args}

{headers}

namespace py = pybind11;
using namespace py::literals;

PYBIND11_MODULE({module_name}, m) {{
  m.doc() = "{module_name} module generated by inexmo {version}";
  m.attr("__checksum__") = "__HASH__";
  {function_definitions}
}}
"""

_function_template = """
  m.def("{function_name}", {function_body} {help} {arg_defs});

"""


@dataclass(frozen=True)
class FunctionSpec:
    name: str
    body: str
    arg_annotations: str
    scope: tuple[str, ...]
    help: str | None = None

    def qualified_cpp_name(self) -> str:
        if self.scope:
            return f"_{'_'.join(self.scope)}_{self.name}"
        return f"_{self.name}"


@dataclass
class ModuleSpec:
    """
    Dataclass for accumulating functions to be built within a module
    """

    functions: set[FunctionSpec] = field(default_factory=set[FunctionSpec])
    headers: list[str] = field(default_factory=list[str])
    include_paths: list[str] = field(default_factory=list[str])
    define_macros: list[str] = field(default_factory=list[str])
    extra_compile_args: list[str] = field(default_factory=list[str])
    extra_link_args: list[str] = field(default_factory=list[str])
    cxx_std: int | None = None

    def add_function(
        self,
        function: FunctionSpec,
        *,
        headers: list[str] | None = None,
        include_paths: list[str] | None = None,
        define_macros: list[str] | None = None,
        extra_compile_args: list[str] | None = None,
        extra_link_args: list[str] | None = None,
        cxx_std: int = 20,
    ) -> Self:
        self.functions.add(function)
        self.headers += headers or []
        self.include_paths += include_paths or []
        self.define_macros += define_macros or []
        self.extra_compile_args += extra_compile_args or []
        self.extra_link_args += extra_link_args or []
        if self.cxx_std and self.cxx_std != cxx_std:
            raise ValueError(
                "Requested C++ standard {} conflicts with previously set standard. Ensure only one standard per module"
            )
        else:
            self.cxx_std = cxx_std
        return self

    def make_source(self, module_name: str) -> tuple[str, str]:
        headers = Itr(group_headers(self.headers)).flatten().fold("", lambda hs, h: hs + f"#include {h}\n")

        # sort to prevent rebuilding when nothing has changed but the function ordering
        function_defs = "\n".join(
            sorted(
                _function_template.format(
                    function_name=f.qualified_cpp_name(),
                    function_body=f.body,
                    arg_defs=f.arg_annotations,
                    help=f', R"""({f.help})"""' if f.help else "",
                )
                for f in self.functions
            )
        )
        # create the code without the hash
        code = _module_template.format(
            version=version,
            cxx_std=self.cxx_std,
            headers=headers,
            extra_include_paths=_deduplicate(self.include_paths),
            # do we need to deduplicate? or will this break something?
            define_macros=" ".join(self.define_macros),
            extra_compile_args=" ".join(_deduplicate(self.extra_compile_args)),
            extra_link_args=" ".join(self.extra_link_args),
            module_name=module_name,
            function_definitions=function_defs,
        )
        # return code and hash
        return code, sha256(code.encode()).hexdigest()
